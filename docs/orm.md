# Работа с базой данных

Работа с базой данных реализована через ORM. В нашей концепции ORM существует несколько основных сущностей, а именно:

- Model. Отвечает за организацию структуры данных.
- QuerySet. Отвечает за построение и выполнение запросов к базе данных.
- Manager. Некоторая прослойка между Model и QuerySet, позволяющая "вынести" часть логики из Model.

А теперь подробнее и понятнее.

## Описание модели (Model)

```php
class Company extends Model
{
    public static function getFields()
    {
        return [
            'name' => [
                'class' => CharField::class,
                'label' => 'Company name'
            ],
            'tagline' => [
                'class' => CharField::class,
                'label' => 'Tagline',
                'null' => true
            ]
        ];
    }
}
```

Как мы видим, основным является описание структуры полей. 

### Атрибуты полей:

*class* - Класс поля, является обязательным
*label* - Наименование для отображения пользователю (н-р в форме редактирования, в админ-панели и т.д.)
*hint* - Подсказка для отображения пользователю
*virtual* - Является ли поле виртуальным, то есть значение данного поля в базе данных не хранится в базе данных, по-умолчанию **false**
*null* - Может ли поле принимать null-значения, по-умолчанию **false**
*blank* - Может ли поле принимать пустые значения, по-умолчанию **false**
*unsigned*, *zerofill* - Атрибуты, соответствующие таковым в SQL, по-умолчанию **false**
*default* - Значение по-умолчанию, по-умолчанию **null**
*editable* - Давать ли возможность добавлять данное поле в автоматически-построенные формы, по-умолчанию **true**
*choices* - Список вариантов выбора (массив ключ-значение). Cм. ниже.

Перечисленные выше атрибуты являются стандартными. 
Для каждого типа поля могут быть так же свои атрибуты, об этом будет указано для каждого поля отдельно.

#### Чуть подробнее о choices

Часто бывает нужно со значениям, хранящимся в базе данных в формате int или varchar сопоставить "человекопонятные" обозначения. 
Статусы заказов, модерации, и т.д.
Атрибут choices упрощает эту задачу.
Ключом массива является значение, хранимое в базе данных, значением массива является строка.

Пример поля с описанным choices-атрибутом:

```php
class Comment extends Model
{
    const STATUS_MODERATION = 1;
    const STATUS_PUBLISHED = 2;
    const STATUS_DECLINED = 3;
    
    public static function getFields()
    {
    ...
        'status' => [
            'class' => IntField::class,
            'label' => 'Статус модерации',
            'choices' => [
                self::STATUS_MODERATION => 'Модерация',
                self::STATUS_PUBLISHED => 'Опубликовано',
                self::STATUS_DECLINED => 'Отклонено'
            ]
        ]
    ...
    }
}
```

Соответственно, в базе данных хранятся только значения 1,2,3, а пользователь будет работать со значениями, понятными для него.
Как получить текстовое значение от поля с описанным choices-атрибутом? Всё достаточно просто:
 
```php
$comment->status__display;
```

Как видим, необходимо обратится не непосредственно к полю *status*, 
для которого определен атрибут choices, а добавить "волшебное"  `__display` и мы получим текстовое отображение соответствующего статуса.

Так же атрибует choices при автоматической генерации формы "превратит" это поле в выпадающий список, что бывает крайне удобно.

### Типы полей

Перечислим основые типы полей ORM. Их можно условно разбить на несколько групп.

Поля, имеющие прямые аналоги в SQL и, по-сути, являющиеся лишь "оберткой" над SQL-значениями 

- IntField
- BigIntField
- DecimalField
- FloatField
- CharField
- TextField
- DateField
- TimeField
- DateTimeField
- BooleanField

Поля, отвечающие за работу с файлами

- FileField
- ImageField

Поля, отвечающие за работу со связями

- ForeignField
- HasManyField
- ManyToManyField

А так же некоторые дополнительные поля, упрощающие определенные действия

- EmailField
- SlugField
- JsonField
- PositionField
- TreeForeignField

А теперь чуть подробнее по каждому

#### IntField, BigIntField

Принимает целочисленные значения.

Дополнительный атрибут *length* соответствует таковому в SQL при описании полей.
По умолчанию у IntField - **11**, у BigIntField - **20**.

#### DecimalField, FloatField

Принимает численные значения.

Тут указываем атрибуты:

*precision* - общее максимальное кол-во знаков, по-умолчанию **10**
и
*scale* - кол-во цифр после запятой, по-умолчанию **2**

#### CharField

Принимает текстовые значения соответствующей длины.

Атрибут *length* отвечает за максимальную длину хранимой строки.
При указании значения более 255, убедитесь что ваша версия СУБД это поддерживает


#### TextField

Принимает текстовые значения.

Аналог TEXT в SQL. Дополнительных атрибутов нет


#### DateField, TimeField, DateTimeField

Принимает строковые значения соответствущих форматов (по маскам "Y-m-d", "H:i:s", "Y-m-d H:i:s" соответственно)

Атрибуты:

*autoNowAdd* - поле примет значение текущего времени/даты при первом сохранении модели
*autoNow* - поле примет значение текущего времени/даты при любом сохранении модели

Удобно пользоваться этими атрибутами для создания полей вида created_at, updated_at с целью отслеживания даты добавления и изменения модели.


#### BooleanField

Принимает значения 1 или 0.

Аналог TINYINT(1) в SQL. Дополнительных атрибутов нет.

#### FileField

Поле, отвечающее за работу с файлами

Принимает значения:

- Локальный файл (*LocalFile*)

```php
$model->file = new LocalFile('/www/sitename/sync/doc_file.pdf');
// OR
$model->file = '/www/sitename/sync/doc_file.pdf';
```

- Удаленный (доступный по ссылке на другом сервере) файл (*RemoteFile*)

```php
$model->file = new RemoteFile('http://example.com/doc_file.pdf');
```

- Загруженный файл (*UploadedFile*). Используется при работе с формой.

Доступные атрибуты:

*md5Name* - Хэшировать имя файла в md5. Как правило, используется для того, чтобы избежать проблем с доступностью файлов имеющих некоторые пробемы с совместимостью кодировки имени файла на сервере.
*templateUploadDir* - Шаблон имени папки для загрузки файлов, по-умолчанию *%Module/%Model/%Y-%m-%d*
*storage* - Наименование хранилища файлов, по умолчанию - *null* (использовать хранилище по-умолчанию)

Получение значения из поля:

- Получение ссылки на файл

```php
$model->file->url
```

- Получение локального пути до файла

```php
$model->file->path
```

- Получение дополниельной информации о файле

```php
$model->file->getExtension();
$model->file->getPathFilename();
$model->file->getPathBasename();
$model->file->getSize();
```

#### ImageField

Поле, отвечающее за работу с изображениями. Интегрировано с Imagine, использует его методы.
Поле унаследовано от FileField, поэтому установка значений в поле и атрибуты совпадают с FileField, но имеется часть дополнительных атрибутов:

*options* - Основные настройки для Imagine, отвечающие за качество изображения
*storeOriginal* - Сохранять ли оригинальный файл, по умолчанию - *true*
*sizes* - Размеры, до которых необходимо изменить исходное изображение

Пример:

```php
class Product extends Model
{
    public static function getFields()
    {
    ...
        'image' => [
            'class' => ImageField::class,
            'label' => 'Изображение',
            'sizes' => [
                'thumb' => [
                    300, 250,
                    'method' => 'cover'
                ],
                'preview' => [
                    400, 300,
                    'method' => 'contain'
                ],
            ]
        ]
    ...
    }
}
```

Представляет собой массив, где ключом является наименование размера, а значением - его параметры. 
Первым параметром указывается ширина итогового изображения, вторым - высота. 
Так же именованным параметром 'method' указывается метод изменения размера изображения. 
Их всего 2 - cover и contain. Работают они так же, как и соответствующие значения css-атрибута background-size.

Получить ссылку на конкретный размер изображения можно вот так:

```php
$model->image->url_preview;
$model->image->url_thumb;
```

#### ForeignField

Поле, отвечающее за связь вида "Многое-к-одному"

Атрибуты:

*modelClass* - класс модели с которой просходит свзязь.

Пример моделей:

```php
class Post extends Model
{
    public static function getFields()
    {
        return [
            'name' => [
                'class' => CharField::class
            ],
        ];
    }
}

class Comment extends Model
{
    public static function getFields()
    {
        return [
            'name' => [
                'class' => CharField::class
            ],
            'post' => [
                'class' => ForeignField::class,
                'modelClass' => Post::class
            ],
        ];
    }
}
```

Установка значения (оба варианта равнозначны)

```php
$comment->post = $post;
$comment->post_id = $post->id;
```

Получение значения

```php
$post = $comment->post;
$postId = $comment->post_id;
```

В данных примерах *$comment* - объект класса *Comment*, *$post* - объект класса *Post*

#### HasManyField

Поле, отвечающее за связь вида "Один-ко-многим". По-сути, является обратной к ForeignField.

Атрибуты:

*modelClass* - класс модели с которой просходит свзязь.
*to* - поле в таблице связанной модели, через которую происходит привязка
*from* - поле в таблице текущей модели, через которую происходит привязка, по-умолчанию - первичный ключ данной модели

В качестве примера возьмем модели из предыдущего поля, лишь немного изменим модель *Post*, указав наше поле

```php
class Post extends Model
{
    public static function getFields()
    {
        return [
            'name' => [
                'class' => CharField::class
            ],
            'comments' => [
                'class' => HasManyField::class,
                'modelClass' => Comment::class,
                'to' => 'post_id',
            ]
        ];
    }
}
```

Установка значений напрямую через данное поле запрещена, для этого необходимо менять соответствующий атрибут в связанных моделях.

В качестве значения из данного поля мы получаем HasManyManager, с помощью которого можем работать с набором связанных моделей. Подробнее о Менеджерах и QuerySet cм. ниже.

Например, получение всех комменатриев к определенному посту:

```php
$comments = $post->comments->all();
```

#### ManyToManyField

Поле, отвечающее за связь вида "Многие-ко-многим".

В первую очередь, скажем о том, что для реализации данной связи необходима дополнительная таблица. 
Эта таблица может содержать только идентификаторы неодходимых записей в связанных таблицах, либо еще какую-то дополнительную информацию.
Поэтому, варианта работы с данным полем 2 - с определением "промежуточной" модели или без таковой

##### ManyToMany без определения промежуточной модели

Для наглядности опишем примеры моделей и разберем работу на их основе

```php
class User extends Model
{
    public static function getFields()
    {
        return [
            'name' => [
                'class' => CharField::class
            ],
            'groups' => [
                'class' => ManyToManyField::class,
                'modelClass' => Group::class
            ],
        ];
    }
}

class Group extends Model
{
    public static function getFields()
    {
        return [
            'name' => [
                'class' => CharField::class
            ],
            'users' => [
                'class' => ManyToManyField::class,
                'modelClass' => User::class
            ],
        ];
    }
}
```

Установка значений может производится несколькими методами:

1. Передача массива объектов / идентификаторов в поле. Связь с данными моделями произойдет после вызова метода save() у принимающей модели.
```php
$user->groups = [$group1->id, $group2];
$user->save();
```
Данный способ так же является универсальным, так как у модели *$user* на момент установки значения в поле *groups* может не быть идентификатора (она пока не существует в БД)

2. Добавление/удаление связей через менеджер
Добавление
```php
$user->groups->link($group1);
$user->groups->link($group2);
```
Удаление
```php
$user->groups->unlink($group1);
$user->groups->unlink($group2);
```

Для *$groups->users* справедливо всё это же самое, они работают с одной и той же таблицей.

В качестве значения из данного поля мы получаем ManyToManyManager, с помощью которого можем работать с набором связанных моделей. Подробнее о Менеджерах и QuerySet cм. ниже.

Например, получение всех групп к определенного пользователя:

```php
$groups = $user->groups->all();
```

##### ManyToMany с определением промежуточной модели

Аналогично, опишем работу на основе примера. Видоизменим предыдущий пример, добавив промежуточную модель для хранения роли пользователя в конкретной группе.

```php
class User extends Model
{
    public static function getFields()
    {
        return [
            'name' => [
                'class' => CharField::class
            ],
            'groups' => [
                'class' => ManyToManyField::class,
                'modelClass' => Group::class,
                'through' => Membership::class
            ],
        ];
    }
}

class Group extends Model
{
    public static function getFields()
    {
        return [
            'name' => [
                'class' => CharField::class
            ],
            'users' => [
                'class' => ManyToManyField::class,
                'modelClass' => User::class,
                'through' => Membership::class
            ],
        ];
    }
}

class Membership extends Model
{
    public static function getFields()
    {
        return [
            'role' => [
                'class' => CharField::class
            ],
            'user' => [
                'class' => ForeignField::class,
                'modelClass' => User::class
            ],
            'group' => [
                'class' => ForeignField::class,
                'modelClass' => Group::class
            ]
        ];
    }
}
```

Работа с данным видом ManyToMany связи аналогична работе без промежуточной модели, за исключением дополнительных возможностей.

Установка значений

Очевидно, что добавлять связи можно обычным созданием промежуточной модели

```php
$memebership = new Membership();
$membership->user = $user;
$membership->group = $group;
$membership->role = 'Director';
$membership->save();
```

Удалять связи можно удалением промежуточной модели

```php
$membeship->delete();
```

При добавлении записей через менеджер, дополнительно можно указывать атрибуты промежуточной модели

```php
$user->groups->link($group1, [
    'role' => 'Director'
]);
```

Кроме этого, промежуточную модель можно использовать для работы с QuerySet.
Например, выбрать всех пользователей, которые хотя бы в одной группе являются руководителями:

```php
User::objects()->filter(['membership__role' => 'Director'])->all();
```